{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["import * as utils from \"@iobroker/adapter-core\";\nimport { entries } from \"alcalzone-shared/objects\";\nimport { exec, fork, type ChildProcess } from \"child_process\";\nimport * as path from \"path\";\nimport { Global as _ } from \"./lib/global\";\nimport {\n\textendChannel,\n\textendDevice,\n\textendState,\n} from \"./lib/iobroker-objects\";\nimport { ObjectCache } from \"./lib/object-cache\";\nimport {\n\tScanExitCodes,\n\tgetMessageReviver,\n\ttype PeripheralInfo,\n\ttype ScanMessage,\n} from \"./lib/scanProcessInterface\";\n// Load all registered plugins\nimport { Socket } from \"net\";\nimport plugins from \"./plugins\";\nimport type { Plugin } from \"./plugins/plugin\";\n\nlet enabledPlugins: Plugin[];\nlet services: string[] = [];\n\n/** Whether new devices may be recorded */\nlet allowNewDevices = false;\nlet resetAllowNewDevicesTimeout: NodeJS.Timeout | undefined;\n\nfunction autoResetAllowNewDevices() {\n\tif (resetAllowNewDevicesTimeout) clearTimeout(resetAllowNewDevicesTimeout);\n\n\t// After 5 minutes, reset it to false\n\tresetAllowNewDevicesTimeout = setTimeout(() => {\n\t\tallowNewDevices = false;\n\t\t_.adapter.setState(\"options.allowNewDevices\", false, true);\n\t\tresetAllowNewDevicesTimeout = undefined;\n\n\t\t_.adapter.log.info(\n\t\t\t\"No longer accepting new devices (automatic timeout)\",\n\t\t);\n\t}, 5000 * 60);\n}\n\n/** Cache of new devices we already ignored */\nconst ignoredNewDeviceIDs = new Set<string>();\n\n// /** MAC addresses of known devices */\n// let knownDevices: string[] = [];\n\n/** How frequent the RSSI of devices should be updated */\nlet rssiUpdateInterval = 0;\n\n/** A reference to the scanning process */\nlet scanProcess: ChildProcess | undefined;\nlet socket: Socket | undefined;\n\n// Adapter-Objekt erstellen\nconst adapter = utils.adapter({\n\tname: \"ble\",\n\t// is called when databases are connected and adapter received configuration.\n\t// start here!\n\tready: async () => {\n\t\t// Adapter-Instanz global machen\n\t\t_.adapter = adapter;\n\n\t\t// Cache objects for 1 minute\n\t\t_.objectCache = new ObjectCache(60000);\n\n\t\t// Workaround f\u00FCr fehlende InstanceObjects nach update\n\t\tawait _.ensureInstanceObjects();\n\n\t\t// Plugins laden\n\t\t_.adapter.log.info(\n\t\t\t`loaded plugins: ${plugins.map((p) => p.name).join(\", \")}`,\n\t\t);\n\t\tconst enabledPluginNames: string[] = (\n\t\t\t(adapter.config.plugins as string) || \"\"\n\t\t)\n\t\t\t.split(\",\")\n\t\t\t.map((p: string) => p.trim().toLowerCase())\n\t\t\t.concat(\"_default\");\n\t\tenabledPlugins = plugins.filter(\n\t\t\t(p) => enabledPluginNames.indexOf(p.name.toLowerCase()) > -1,\n\t\t);\n\t\t_.adapter.log.info(\n\t\t\t`enabled plugins: ${enabledPlugins.map((p) => p.name).join(\", \")}`,\n\t\t);\n\n\t\t// Bring the monitored service names into the correct form\n\t\tif (adapter.config.services === \"*\") {\n\t\t\tservices = [];\n\t\t\t_.adapter.log.info(`monitoring all services`);\n\t\t} else {\n\t\t\tservices = (adapter.config.services as string)\n\t\t\t\t.split(\",\") // get manually defined services\n\t\t\t\t.concat(...enabledPlugins.map((p) => p.advertisedServices)) // concat with plugin-defined ones\n\t\t\t\t.reduce((acc, s) => acc.concat(s), [] as string[]) // flatten the arrays\n\t\t\t\t.map((s) => fixServiceName(s)) // cleanup the names\n\t\t\t\t.filter((s) => s !== \"\")\n\t\t\t\t.reduce((acc: any[], s) => {\n\t\t\t\t\t// filter out duplicates\n\t\t\t\t\tif (acc.indexOf(s) === -1) acc.push(s);\n\t\t\t\t\treturn acc;\n\t\t\t\t}, []);\n\t\t\t_.adapter.log.info(`monitored services: ${services.join(\", \")}`);\n\t\t}\n\n\t\t// Limit RSSI updates\n\t\tif (adapter.config.rssiThrottle != null) {\n\t\t\trssiUpdateInterval = Math.max(\n\t\t\t\t0,\n\t\t\t\tMath.min(10000, adapter.config.rssiThrottle),\n\t\t\t);\n\t\t}\n\t\t// monitor our own states and objects\n\t\tadapter.subscribeStates(\"*\");\n\t\tadapter.subscribeObjects(\"*\");\n\n\t\t// Beim Start des Adapters sicher stellen, dass keine neuen Ger\u00E4te erfasst werden,\n\t\t// bis der User es explizit erlaubt.\n\t\tawait adapter.setStateAsync(\"options.allowNewDevices\", false, true);\n\n\t\t// And start scanning\n\t\tif (!process.env.TESTING) {\n\t\t\tif (adapter.config.server) {\n\t\t\t\tconnectToBLEServer();\n\t\t\t} else {\n\t\t\t\tstartScanProcess();\n\t\t\t}\n\t\t}\n\t},\n\n\t// is called when adapter shuts down - callback has to be called under any circumstances!\n\tunload: (callback) => {\n\t\ttry {\n\t\t\tscanProcess?.kill();\n\t\t} catch {}\n\t\tcallback();\n\t},\n\n\t// is called if a subscribed object changes\n\tobjectChange: (id, obj) => {\n\t\tif (!!obj) {\n\t\t\t// it has just been changed, so update the cached object\n\t\t\t_.objectCache.updateObject(obj);\n\t\t} else {\n\t\t\t// it has been deleted, so delete it from the cache\n\t\t\t_.objectCache.invalidateObject(id);\n\t\t}\n\t},\n\n\t// is called if a subscribed state changes\n\tstateChange: (id, state) => {\n\t\tif (\n\t\t\t/options\\.allowNewDevices$/.test(id) &&\n\t\t\tstate != undefined &&\n\t\t\t!state.ack\n\t\t) {\n\t\t\tif (\n\t\t\t\ttypeof state.val === \"boolean\" &&\n\t\t\t\tstate.val !== allowNewDevices\n\t\t\t) {\n\t\t\t\tallowNewDevices = state.val;\n\t\t\t\t// ACK the state change\n\t\t\t\t_.adapter.setState(id, state.val, true);\n\t\t\t\t_.adapter.log.info(\n\t\t\t\t\tallowNewDevices\n\t\t\t\t\t\t? \"Now accepting new devices\"\n\t\t\t\t\t\t: \"No longer accepting new devices\",\n\t\t\t\t);\n\n\t\t\t\tif (allowNewDevices) {\n\t\t\t\t\t// Whenever allowNewDevices is set to true,\n\t\t\t\t\t// forget all devices we previously ignored\n\t\t\t\t\tignoredNewDeviceIDs.clear();\n\t\t\t\t\t// Clear or restart the auto-reset timer\n\t\t\t\t\tautoResetAllowNewDevices();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tmessage: async (obj) => {\n\t\t// responds to the adapter that sent the original message\n\t\tfunction respond(response: any) {\n\t\t\tif (obj.callback)\n\t\t\t\tadapter.sendTo(obj.from, obj.command, response, obj.callback);\n\t\t}\n\t\t// some predefined responses so we only have to define them once\n\t\tconst predefinedResponses = {\n\t\t\tACK: { error: null },\n\t\t\tOK: { error: null, result: \"ok\" },\n\t\t\tERROR_UNKNOWN_COMMAND: { error: \"Unknown command!\" },\n\t\t\tMISSING_PARAMETER: (paramName: string) => {\n\t\t\t\treturn { error: 'missing parameter \"' + paramName + '\"!' };\n\t\t\t},\n\t\t\tCOMMAND_RUNNING: { error: \"command running\" },\n\t\t};\n\t\t// make required parameters easier\n\t\t// function requireParams(params: string[]) {\n\t\t// \tif (!(params && params.length)) return true;\n\t\t// \tfor (const param of params) {\n\t\t// \t\tif (!(obj.message && obj.message.hasOwnProperty(param))) {\n\t\t// \t\t\trespond(predefinedResponses.MISSING_PARAMETER(param));\n\t\t// \t\t\treturn false;\n\t\t// \t\t}\n\t\t// \t}\n\t\t// \treturn true;\n\t\t// }\n\n\t\t// handle the message\n\t\tif (obj) {\n\t\t\tswitch (obj.command) {\n\t\t\t\tcase \"getHCIPorts\":\n\t\t\t\t\texec(\"hciconfig | grep hci\", (error, stdout, _stderr) => {\n\t\t\t\t\t\t// hci1:   Type: BR/EDR  Bus: USB\n\t\t\t\t\t\t// hci0:   Type: BR/EDR  Bus: UART\n\t\t\t\t\t\tif (error != null) {\n\t\t\t\t\t\t\trespond({ error });\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// parse index and bus type\n\t\t\t\t\t\tconst ports: { index: number; bus: string }[] = [];\n\t\t\t\t\t\tconst regex = /^hci(\\d+)\\:.+Bus\\:\\s(\\w+)$/gm;\n\t\t\t\t\t\tlet result: RegExpExecArray | null;\n\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tresult = regex.exec(stdout);\n\t\t\t\t\t\t\tif (!(result && result.length)) break;\n\t\t\t\t\t\t\tconst port = { index: +result[1], bus: result[2] };\n\t\t\t\t\t\t\tports.push(port);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trespond({ error: null, result: ports });\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\tdefault:\n\t\t\t\t\trespond(predefinedResponses.ERROR_UNKNOWN_COMMAND);\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t},\n});\n\nfunction startScanProcess() {\n\tconst args: string[] = [\"-s\", ...services];\n\tif (adapter.config.hciDevice) {\n\t\targs.push(\"-d\", adapter.config.hciDevice.toString());\n\t}\n\tadapter.log.info(\"starting scanner process...\");\n\tscanProcess = fork(path.join(__dirname, \"scanProcess\"), args, {\n\t\tstdio: [\"pipe\", \"pipe\", \"pipe\", \"ipc\"],\n\t}).on(\"exit\", (code, signal) => {\n\t\tif (\n\t\t\t!signal &&\n\t\t\tcode !== 0 &&\n\t\t\tcode !== ScanExitCodes.RequireNobleFailed\n\t\t) {\n\t\t\tadapter.log.warn(\"scanner process crashed, restarting...\");\n\t\t\tsetImmediate(startScanProcess);\n\t\t} else {\n\t\t\tscanProcess = undefined;\n\t\t}\n\t});\n\tscanProcess.on(\"message\", getMessageReviver(handleMessage));\n}\n\nfunction connectToBLEServer() {\n\tsocket = new Socket();\n\n\tconst reviver = getMessageReviver(handleMessage);\n\n\tsocket\n\t\t.on(\"close\", () => {\n\t\t\tadapter.log.info(\"Disconnected from BLE server\");\n\t\t\tadapter.setState(\"info.connection\", false, true);\n\t\t})\n\t\t.on(\"connect\", () => {\n\t\t\tadapter.log.info(\"Connected to BLE server\");\n\t\t\tadapter.setState(\"info.connection\", true, true);\n\t\t})\n\t\t.on(\"data\", (data) => {\n\t\t\ttry {\n\t\t\t\tconst msg = JSON.parse(data.toString());\n\t\t\t\treviver(msg);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\t\t});\n\n\tconst [host, port] = adapter.config.server.split(\":\", 2);\n\n\tadapter.log.info(\"connecting to BLE server...\");\n\tsocket.connect({\n\t\thost,\n\t\tport: +port,\n\t});\n}\n\nfunction handleMessage(message: ScanMessage) {\n\tswitch (message.type) {\n\t\tcase \"connected\":\n\t\t\tadapter.setState(\"info.connection\", true, true);\n\t\t\tbreak;\n\t\tcase \"disconnected\":\n\t\t\tadapter.setState(\"info.connection\", false, true);\n\t\t\tbreak;\n\t\tcase \"discover\":\n\t\t\tonDiscover(message.peripheral);\n\t\t\tbreak;\n\t\tcase \"driverState\":\n\t\t\tadapter.setState(\"info.driverState\", message.driverState, true);\n\t\t\tbreak;\n\t\tcase \"error\": // fall through\n\t\tcase \"fatal\":\n\t\t\thandleScanProcessError(message.error);\n\t\t\tbreak;\n\t\tcase \"log\":\n\t\t\tadapter.log[message.level ?? \"info\"](message.message);\n\t\t\tbreak;\n\t}\n}\n\nfunction fixServiceName(name: string | null | undefined): string {\n\tif (name == null) return \"\";\n\tname = name.trim();\n\t// No whitespace\n\tfor (const char of [\"\\r\", \"\\n\", \"\\t\", \" \"]) {\n\t\tname = name.replace(char, \"\");\n\t}\n\t// No leading 0x\n\tname = name.replace(/^0x/, \"\");\n\t// lowerCase\n\treturn name.toLowerCase();\n}\n\nasync function onDiscover(peripheral: PeripheralInfo) {\n\tif (peripheral == null) return;\n\n\tlet serviceDataIsNotEmpty = false;\n\tlet manufacturerDataIsNotEmpty = false;\n\n\t_.adapter.log.debug(`discovered peripheral ${peripheral.address}`);\n\t_.adapter.log.debug(\n\t\t`  has advertisement: ${peripheral.advertisement != null}`,\n\t);\n\tif (peripheral.advertisement != null) {\n\t\t_.adapter.log.debug(\n\t\t\t`  has serviceData: ${\n\t\t\t\tperipheral.advertisement.serviceData != null\n\t\t\t}`,\n\t\t);\n\t\tif (peripheral.advertisement.serviceData != null) {\n\t\t\t_.adapter.log.debug(\n\t\t\t\t`  serviceData = ${JSON.stringify(\n\t\t\t\t\tperipheral.advertisement.serviceData,\n\t\t\t\t)}`,\n\t\t\t);\n\t\t\tserviceDataIsNotEmpty =\n\t\t\t\tperipheral.advertisement.serviceData.length > 0;\n\t\t}\n\t\t_.adapter.log.debug(\n\t\t\t`  has manufacturerData: ${\n\t\t\t\tperipheral.advertisement.manufacturerData != null\n\t\t\t}`,\n\t\t);\n\t\tif (peripheral.advertisement.manufacturerData != null) {\n\t\t\t_.adapter.log.debug(\n\t\t\t\t`  manufacturerData = ${peripheral.advertisement.manufacturerData.toString(\n\t\t\t\t\t\"hex\",\n\t\t\t\t)}`,\n\t\t\t);\n\t\t\tmanufacturerDataIsNotEmpty =\n\t\t\t\tperipheral.advertisement.manufacturerData.length > 0;\n\t\t}\n\t} else {\n\t\t// don't create devices for peripherals without advertised data\n\t\treturn;\n\t}\n\t// create devices if we selected to allow empty devices\n\t// or the peripheral transmits serviceData or manufacturerData\n\tif (\n\t\t!adapter.config.allowEmptyDevices &&\n\t\t!serviceDataIsNotEmpty &&\n\t\t!manufacturerDataIsNotEmpty\n\t) {\n\t\treturn;\n\t}\n\n\tconst deviceId = peripheral.address;\n\n\t// find out which plugin is handling this\n\tlet plugin: Plugin | undefined;\n\tfor (const p of enabledPlugins) {\n\t\tif (p.isHandling(peripheral)) {\n\t\t\t_.adapter.log.debug(`plugin ${p.name} is handling ${deviceId}`);\n\t\t\tplugin = p;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!plugin) {\n\t\t_.adapter.log.warn(\n\t\t\t`no handling plugin found for peripheral ${peripheral.id}`,\n\t\t);\n\t\treturn;\n\t}\n\n\t// Test if we may record this device\n\tif (!allowNewDevices) {\n\t\t// We may not. First test if we already ignored this device\n\t\tif (ignoredNewDeviceIDs.has(deviceId)) return;\n\t\t// If not, check if the RSSI object exists, as that exists for every one\n\t\tif (\n\t\t\t!(await _.objectCache.objectExists(\n\t\t\t\t`${_.adapter.namespace}.${deviceId}.rssi`,\n\t\t\t))\n\t\t) {\n\t\t\t// This is a new device. Remember that we need to ignore it\n\t\t\tignoredNewDeviceIDs.add(deviceId);\n\t\t\treturn;\n\t\t}\n\t\t// This is a known device\n\t}\n\n\t// Always ensure the rssi state exists and gets a value\n\tawait extendState(`${deviceId}.rssi`, {\n\t\tid: \"rssi\",\n\t\tcommon: {\n\t\t\trole: \"value.rssi\",\n\t\t\tname: \"signal strength (RSSI)\",\n\t\t\tdesc: \"Signal strength of the device\",\n\t\t\ttype: \"number\",\n\t\t\tread: true,\n\t\t\twrite: false,\n\t\t},\n\t\tnative: {},\n\t});\n\t// update RSSI information\n\tconst rssiState = await adapter.getStateAsync(`${deviceId}.rssi`);\n\tif (\n\t\trssiState == null ||\n\t\t// Allow updating the unchanged state because some people use it for presence detection\n\t\trssiState.ts + rssiUpdateInterval < Date.now() // But don't update too frequently\n\t) {\n\t\t_.adapter.log.debug(`updating rssi state for ${deviceId}`);\n\t\tawait adapter.setStateAsync(`${deviceId}.rssi`, peripheral.rssi, true);\n\t}\n\n\t// Now update device-specific objects and states\n\tconst context = plugin.createContext(peripheral);\n\tconst objects = plugin.defineObjects(context);\n\tconst values = plugin.getValues(context);\n\n\t// We can't do anything without objects\n\tif (objects == null) return;\n\n\t// Ensure the device object exists\n\tawait extendDevice(deviceId, peripheral, objects.device);\n\t// Ensure the channel objects exist (optional)\n\tif (objects.channels != null && objects.channels.length > 0) {\n\t\tawait Promise.all(\n\t\t\tobjects.channels.map((c) =>\n\t\t\t\textendChannel(deviceId + \".\" + c.id, c),\n\t\t\t),\n\t\t);\n\t}\n\t// Ensure the state objects exist. These might change in every advertisement frame\n\tawait Promise.all(\n\t\tobjects.states.map((s) => extendState(deviceId + \".\" + s.id, s)),\n\t);\n\n\t// Now fill the states with values\n\tif (values != null) {\n\t\t_.adapter.log.debug(\n\t\t\t`${deviceId} > got values: ${JSON.stringify(values)}`,\n\t\t);\n\t\t// eslint-disable-next-line prefer-const\n\t\tfor (let [stateId, value] of entries(values)) {\n\t\t\t// Fix special chars\n\t\t\tstateId = stateId.replace(/[\\(\\)]+/g, \"\").replace(\" \", \"_\");\n\t\t\t// set the value if there's an object for the state\n\t\t\tconst iobStateId = `${adapter.namespace}.${deviceId}.${stateId}`;\n\t\t\tif ((await _.objectCache.getObject(iobStateId)) != null) {\n\t\t\t\t_.adapter.log.debug(`setting state ${iobStateId}`);\n\t\t\t\tawait adapter.setStateChangedAsync(\n\t\t\t\t\tiobStateId,\n\t\t\t\t\tvalue ?? null,\n\t\t\t\t\ttrue,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t_.adapter.log.warn(\n\t\t\t\t\t`skipping state ${iobStateId} because the object does not exist`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t_.adapter.log.debug(`${deviceId} > got no values`);\n\t}\n}\n\nfunction handleScanProcessError(err: Error) {\n\tif (\n\t\t/compatible USB Bluetooth/.test(err.message) ||\n\t\t/LIBUSB_ERROR_NOT_SUPPORTED/.test(err.message)\n\t) {\n\t\tterminate(\"No compatible BLE 4.0 hardware found!\");\n\t} else if (\n\t\t/NODE_MODULE_VERSION/.test(err.message) &&\n\t\tadapter.supportsFeature?.(\"CONTROLLER_NPM_AUTO_REBUILD\")\n\t) {\n\t\tterminate(\"A dependency requires a rebuild.\", 13);\n\t} else if (err.message.includes(`The value of \"offset\" is out of range`)) {\n\t\t// ignore, this happens in noble sometimes\n\t\t(adapter?.log ?? console).error(err.message);\n\t} else if (err.message.includes(\"EAFNOSUPPORT\")) {\n\t\tterminate(\n\t\t\t\"Unsupported Address Family (EAFNOSUPPORT). If ioBroker is running in a Docker container, make sure that the container uses host mode networking.\",\n\t\t);\n\t} else {\n\t\t// This is something unexpected. We don't want to bring down the main process, so just log it\n\t\t(adapter?.log ?? console).error(err.message);\n\t}\n}\n\nfunction terminate(\n\treason: string = \"no reason given\",\n\texitCode: number = 11,\n): never {\n\tif (adapter) {\n\t\tadapter.log.error(`Terminating because ${reason}`);\n\t\tadapter.terminate?.(reason, exitCode);\n\t}\n\treturn process.exit(exitCode);\n}\n"],
  "mappings": "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",
  "names": []
}
